# 小哈书

## 1. 什么是 Spring Boot Starter ?

Spring Boot Starter 就像是一个“工具包”，里面已经包含了你所需要的东西。它们把一些常用的功能和技术打包好了，比如处理数据库、处理 Web 请求等等。你只需要在你的项目中引入这些 Starter，它们就会自动帮你配置好所需的依赖项和参数。这样，你就可以省去很多繁琐的配置工作。

举个栗子，当你想要使用 Spring Boot 开发一个 Web 应用时，只需要引入 `spring-boot-starter-web` Starter。这个 Starter 包含了一系列依赖项和配置，使得开发 Web 应用变得更加简单。

具体来说，引入 `spring-boot-starter-web` Starter 后，你可以享受到以下好处：

- **内嵌的 Web 服务器支持**：Spring Boot 内置了多种 Web 服务器支持，比如 Tomcat、Jetty、Undertow。`spring-boot-starter-web` 会自动配置一个默认的 Web 服务器，你无需手动配置即可启动你的应用。
- **Spring MVC 框架支持**：Spring Boot 基于 Spring MVC 构建了强大的 Web 开发框架，包括了控制器、视图解析器等。引入 `spring-boot-starter-web` 后，你可以直接使用 Spring MVC 来处理 Web 请求。
- **静态资源支持**：`spring-boot-starter-web` Starter 自动配置了对静态资源（如 HTML、CSS、JavaScript 文件）的处理，你可以直接在项目中放置这些文件，Spring Boot 就能够正确地访问它们。
- **自动配置**：Spring Boot 会根据你的 classpath 自动配置应用程序。比如，如果你引入了 `spring-boot-starter-web`，Spring Boot 就会自动配置 DispatcherServlet、ViewResolver 等关键组件，从而让你的 Web 应用能够顺利地工作起来。

简而言之，Spring Boot Starter 是一种方便的方式，让你能够更快、更轻松地开始使用 Spring Boot 框架，并集成各种常用功能和技术。

## 2.JSON 工具类

由于在**日志切面** `starter` 组件中，需要以 `json` 的格式打印出参，所以，我们需要先封装一个 `Json` 工具类。

##  3.配置类

- **`@Configuration`** 是 Spring 中用于定义普通配置类的注解，开发者手动定义 Bean 和其他配置。
- **`@AutoConfiguration`** 是 Spring Boot 中用于标记自动配置类的注解，它通常与条件注解一起使用，根据类路径和环境自动决定是否启用某个配置。
- **`@EnableAutoConfiguration`** 启用自动配置机制，通常通过 `@SpringBootApplication` 注解来间接使用。

## 4.自定义starter

### **自定义 Starter 的结构**

一个标准的自定义 Starter 主要包含以下几部分：

1. **`META-INF/spring.factories` 文件**：用于注册自动配置类，Spring Boot 会根据这个文件自动加载和启用相应的配置。
2. **自动配置类**：封装具体的功能和配置，比如数据库连接池、消息队列等的自动配置。
3. **依赖**：你可能会在 Starter 中添加一些常用的库和框架，简化其他开发者的配置工作。
4. **其他资源**：如配置文件模板、静态资源等。

#### 第一步：创建 Starter 项目

创建一个新的 Maven 或 Gradle 项目，这个项目将作为你的自定义 Starter。

例如，使用 Maven，你可以创建一个新的模块，命名为 `my-logging-starter`。

#### 第二步：创建自动配置类

自动配置类负责实现 Spring Boot 的自动配置功能，通常使用 `@Configuration` 注解。你可以在自动配置类中使用 `@Conditional` 系列注解来根据环境条件自动配置特定的 Bean。

```java
package com.example.logging.config;

import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties(LoggingProperties.class)  // 加载自定义的属性
public class LoggingAutoConfiguration {

    @Bean
    public LoggingService loggingService() {
        return new LoggingServiceImpl();
    }

    // 其他的自动配置...
}
```

#### 第三步：创建 `META-INF/spring.factories` 文件

在 `src/main/resources/META-INF/` 目录下创建 `spring.factories` 文件，并在其中注册你的自动配置类。

**文件路径**：

```bash
bash /src/main/resources/META-INF/spring.factories
```

**内容示例**：

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.logging.config.LoggingAutoConfiguration
```

该文件告诉 Spring Boot 在启动时自动加载 `LoggingAutoConfiguration` 配置类。

#### 第四步：定义配置属性类（如果需要）

如果你希望允许用户在 `application.properties` 或 `application.yml` 文件中配置自定义的属性，可以创建一个配置属性类。

```java
package com.example.logging.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "logging")
public class LoggingProperties {

    private String logLevel;
    private String logFilePath;

    // Getters and Setters
}
```

#### 第五步：打包并发布 Starter

完成自动配置类、`spring.factories` 文件、依赖等设置后，你可以将这个 Starter 打包并发布到 Maven 仓库，供其他应用使用。

在 `pom.xml` 中配置你的 Starter 依赖：

```xml
<dependency>
    <groupId>com.example</groupId>
    <artifactId>my-logging-starter</artifactId>
    <version>1.0.0</version>
</dependency>
```

#### 第六步：使用自定义 Starter

在其他 Spring Boot 项目中使用时，只需要在 `pom.xml` 文件中添加对该 Starter 的依赖。Spring Boot 会自动加载和配置该 Starter 中的功能。

### 5. **示例：自定义日志 Starter**

假设我们要创建一个自定义日志 Starter。步骤如下：

#### 1. 创建 Starter 项目

创建一个名为 `my-logging-starter` 的 Maven 模块。

#### 2. 创建自动配置类

```
LoggingAutoConfiguration.java
java复制package com.example.logging.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class LoggingAutoConfiguration {

    @Bean
    public LoggingService loggingService() {
        return new LoggingServiceImpl();
    }
}
```

#### 3. 创建 `spring.factories` 文件

```
src/main/resources/META-INF/spring.factories
properties复制org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.logging.config.LoggingAutoConfiguration
```

#### 4. 创建配置属性类（如果需要）

```
LoggingProperties.java
java复制package com.example.logging.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "logging")
public class LoggingProperties {

    private String logLevel = "INFO";  // 默认值

    // Getter 和 Setter
}
```

#### 5. 创建一个接口和实现类

```
LoggingService.java
java复制package com.example.logging;

public interface LoggingService {
    void log(String message);
}
LoggingServiceImpl.java
java复制package com.example.logging;

public class LoggingServiceImpl implements LoggingService {

    @Override
    public void log(String message) {
        System.out.println("LOG: " + message);
    }
}
```

#### 6. 打包和发布

将整个项目打包成 JAR 文件并上传到 Maven 仓库，或者直接将其作为本地依赖。

#### 7. 在其他项目中使用

在其他 Spring Boot 应用中，添加对 `my-logging-starter` 的依赖：

```xml
<dependency>
    <groupId>com.example</groupId>
    <artifactId>my-logging-starter</artifactId>
    <version>1.0.0</version>
</dependency>
```

Spring Boot 会自动配置日志相关的 Bean。

## 6. 如何进行AOP编程

### 1. **定义 `@Log` 注解**

首先，我们需要定义一个 `@Log` 注解，用来标记需要进行日志记录的业务方法。

```java
package com.example.logging.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// 标注在方法上
@Target(ElementType.METHOD)
// 保留策略为运行时
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
    // 可根据需要添加一些属性，例如日志级别等
    String value() default "";
}
```

### 2. **创建 AOP 切面**

接着，我们需要创建一个 AOP 切面类来拦截所有标注了 `@Log` 注解的方法，打印方法的入参、出参以及运行时间。

#### 依赖

首先，确保你的项目已经引入了 AOP 相关的依赖。如果使用的是 Spring Boot，通常需要引入 `spring-boot-starter-aop` 依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

#### AOP 切面实现

```java
package com.example.logging.aop;

import com.example.logging.annotation.Log;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import java.util.Arrays;

@Aspect
@Component
public class LogAspect {

    private static final Logger logger = LoggerFactory.getLogger(LogAspect.class);

    // 定义切点：拦截所有注解了@Log的方法
    @Pointcut("@annotation(com.example.logging.annotation.Log)")
    public void logMethods() {}

    // 前置通知：方法执行前
    @Before("logMethods()")
    public void logBefore(JoinPoint joinPoint) {
        // 打印方法名称
        String methodName = joinPoint.getSignature().getName();
        // 打印方法入参
        Object[] args = joinPoint.getArgs();
        logger.info("Method [{}] called with arguments: {}", methodName, Arrays.toString(args));
    }

    // 环绕通知：方法执行前后
    @Around("logMethods()")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        // 获取方法名
        String methodName = joinPoint.getSignature().getName();
        // 获取方法入参
        Object[] args = joinPoint.getArgs();
        // 记录方法开始时间
        long startTime = System.currentTimeMillis();

        // 执行目标方法
        Object result = joinPoint.proceed();

        // 记录方法结束时间
        long endTime = System.currentTimeMillis();
        // 打印方法出参和运行时间
        logger.info("Method [{}] executed in {} ms. Arguments: {}. Return: {}", methodName, endTime - startTime, Arrays.toString(args), result);

        return result;
    }

    // 后置通知：方法执行后
    @After("logMethods()")
    public void logAfter(JoinPoint joinPoint) {
        // 这里可以添加日志记录执行完后的操作（如果需要）
    }
}
```

## 7.整合mybatis

将 **Spring Boot** 项目与 **MyBatis** 整合的步骤可以分为几个主要部分：引入依赖、配置数据源、配置 MyBatis、编写实体类、Mapper 接口和 XML 映射文件、以及进行数据库操作。以下是详细的步骤：

### 1. **引入依赖**

首先，在 `pom.xml` 文件中添加 Spring Boot 和 MyBatis 所需的依赖。

```xml
xml复制<dependencies>
    <!-- Spring Boot Starter Web (如果你有 Web 相关需求) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring Boot Starter DataSource (数据库连接池) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    
    <!-- MyBatis Spring Boot Starter -->
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.2.0</version> <!-- 使用最新的版本 -->
    </dependency>
    
    <!-- MySQL 数据库驱动 -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>

    <!-- Spring Boot Starter Test (用于测试) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 2. **配置数据源（`application.properties` 或 `application.yml`）**

在 `application.properties` 或 `application.yml` 中配置数据库连接信息。

#### 使用 `application.properties`：

```properties
properties复制# 数据源配置
spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=your_password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# MyBatis 配置
mybatis.mapper-locations=classpath:/mappers/*.xml
mybatis.type-aliases-package=com.quanxiaoha.xiaohashu.auth.domain.dataobject
mybatis.configuration.map-underscore-to-camel-case=true  # 开启驼峰命名规则
```

#### 使用 `application.yml`：

```yaml
yaml复制spring:
  datasource:
    url: jdbc:mysql://localhost:3306/your_database_name?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC
    username: root
    password: your_password
    driver-class-name: com.mysql.cj.jdbc.Driver

mybatis:
  mapper-locations: classpath:/mappers/*.xml
  type-aliases-package: com.quanxiaoha.xiaohashu.auth.domain.dataobject
  configuration:
    map-underscore-to-camel-case: true  # 开启驼峰命名规则
```

### 3. **创建实体类（POJO）**

创建一个 Java 类，作为数据库表的实体对象。

```java
java复制package com.quanxiaoha.xiaohashu.auth.domain.dataobject;

import java.time.LocalDateTime;

public class UserDO {

    private Long id;
    private String username;
    private String password;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;

    // Getters and Setters

}
```

### 4. **创建 Mapper 接口**

创建一个 MyBatis 的 `Mapper` 接口，定义需要执行的 SQL 操作。

```java
java复制package com.quanxiaoha.xiaohashu.auth.domain.mapper;

import com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface UserDOMapper {

    UserDO selectByPrimaryKey(Long id);

    List<UserDO> selectAll();

    void insert(UserDO user);

    void update(UserDO user);

    void delete(Long id);
}
```

### 5. **创建 Mapper XML 文件**

在 `resources/mappers` 目录下创建 MyBatis 的映射文件（XML）。这个文件用于定义 SQL 语句和结果映射。

#### 例如，创建 `UserDOMapper.xml`：

```xml
xml复制<mapper namespace="com.quanxiaoha.xiaohashu.auth.domain.mapper.UserDOMapper">

    <!-- 查询所有用户 -->
    <select id="selectAll" resultType="com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO">
        SELECT id, username, password, create_time, update_time FROM t_user
    </select>

    <!-- 根据主键查询 -->
    <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultType="com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO">
        SELECT id, username, password, create_time, update_time FROM t_user WHERE id = #{id}
    </select>

    <!-- 插入用户 -->
    <insert id="insert" parameterType="com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO">
        INSERT INTO t_user (username, password, create_time, update_time)
        VALUES (#{username}, #{password}, #{createTime}, #{updateTime})
    </insert>

    <!-- 更新用户 -->
    <update id="update" parameterType="com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO">
        UPDATE t_user
        SET username = #{username}, password = #{password}, update_time = #{updateTime}
        WHERE id = #{id}
    </update>

    <!-- 删除用户 -->
    <delete id="delete" parameterType="java.lang.Long">
        DELETE FROM t_user WHERE id = #{id}
    </delete>

</mapper>
```

### 6. **启用 MyBatis**

Spring Boot 自动配置会扫描 `@Mapper` 注解标记的接口。如果需要自定义 MyBatis 的配置（如更改扫描路径等），可以使用 `@MapperScan` 注解指定扫描路径。

#### 启用 MyBatis 的注解配置（在启动类中）：

```java
java复制package com.quanxiaoha.xiaohashu.auth;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan("com.quanxiaoha.xiaohashu.auth.domain.mapper")  // 扫描 Mapper 接口所在包
public class XiaohashuAuthApplication {

    public static void main(String[] args) {
        SpringApplication.run(XiaohashuAuthApplication.class, args);
    }
}
```

### 7. **创建 Service 层（可选）**

在 Service 层中，你可以调用 Mapper 接口来执行数据库操作。

```java
java复制package com.quanxiaoha.xiaohashu.auth.service;

import com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO;
import com.quanxiaoha.xiaohashu.auth.domain.mapper.UserDOMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserService {

    @Autowired
    private UserDOMapper userDOMapper;

    public UserDO getUserById(Long id) {
        return userDOMapper.selectByPrimaryKey(id);
    }

    public List<UserDO> getAllUsers() {
        return userDOMapper.selectAll();
    }

    public void createUser(UserDO user) {
        userDOMapper.insert(user);
    }

    public void updateUser(UserDO user) {
        userDOMapper.update(user);
    }

    public void deleteUser(Long id) {
        userDOMapper.delete(id);
    }
}
```

## 8.数据库密码加密

代码如下：

```typescript
package com.quanxiaoha.xiaohashu.auth;

import com.alibaba.druid.filter.config.ConfigTools;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;


@SpringBootTest
@Slf4j
class DruidTests {


    /**
     * Druid 密码加密
     */
    @Test
    @SneakyThrows
    void testEncodePassword() {
        // 你的密码
        String password = "123456";
        String[] arr = ConfigTools.genKeyPair(512);

        // 私钥
        log.info("privateKey: {}", arr[0]);
        // 公钥
        log.info("publicKey: {}", arr[1]);

        // 通过私钥加密密码
        String encodePassword = ConfigTools.encrypt(arr[0], password);
        log.info("password: {}", encodePassword);
    }

}
```

> 解释一下上述代码：
>
> 1. `String password = "123456";`：定义了要加密的密码。
> 2. `String[] arr = ConfigTools.genKeyPair(512);`：调用 `ConfigTools` 类的 `genKeyPair` 方法生成 RSA 密钥对。RSA 是一种非对称加密算法，`512` 表示密钥长度为 512 位。
> 3. `log.info("privateKey: {}", arr[0]);` 和 `log.info("publicKey: {}", arr[1]);`：分别打印生成的私钥和公钥。私钥用于加密，公钥用于解密。
> 4. `String encodePassword = ConfigTools.encrypt(arr[0], password);`：调用 `ConfigTools` 类的 `encrypt` 方法，使用生成的私钥对密码进行加密。这里将生成的私钥和密码作为参数传入，返回加密后的密码。
> 5. `log.info("password: {}", encodePassword);`：打印加密后的密码。

核心配置如下：

```yaml
spring:
  datasource:
    // 省略...
    password: A2qT03X7KlL4v/F2foD6kV/Ch9gpNBWOh1qoCywanjv1AsI7f9x3iAyR9NkUKeV+FMo+halCTzy5Llbk2VOrVQ== # 数据库密码
    type: com.alibaba.druid.pool.DruidDataSource
    druid: # Druid 连接池
      // 省略...
      connectionProperties: config.decrypt=true;config.decrypt.key=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIaJmhsfN14oM+bghiOfARP6YgIiArekviyAOEa9Dt8spf4W38kSJShGs0NkzT3btqJB0O2o0X/yfVE8kqme1jMCAwEAAQ==
      // 省略...
      filter:
        config:
          enabled: true
        // 省略...
```

> 解释一下上述配置项：
>
> 1. `password: A2qT03X7KlL4v/F2foD6kV/Ch9gpNBWOh1qoCywanjv1AsI7f9x3iAyR9NkUKeV+FMo+halCTzy5Llbk2VOrVQ==`：这里的密码改为加密后的密码。
> 2. `connectionProperties: config.decrypt=true;config.decrypt.key=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIaJmhsfN14oM+bghiOfARP6YgIiArekviyAOEa9Dt8spf4W38kSJShGs0NkzT3btqJB0O2o0X/yfVE8kqme1jMCAwEAAQ==`：这里配置了连接属性，其中 `config.decrypt=true` 表示开启密码解密功能，`config.decrypt.key` 是用于解密的密钥，即上面单元测试生成**公钥**。在 Druid 连接池中，如果我们的密码已经经过了加密处理，就需要在连接属性中配置解密相关的参数，以便 Druid 能够正确解密密码，然后连接到数据库。
> 3. `filter.config.enabled: true`：这里配置了 Druid 连接池的 `filter`，其中 `config` 是一个配置项，`enabled: true` 表示开启该配置项。这个配置项通常用于配置 Druid 连接池的一些额外功能，比如密码解密等。

## 9.根据数据库表自动生成do，mapper与mapper.xml

在 `pom.xml` 文件中添加该插件：

```php-template
    <build>
        <plugins>
			// 省略...
			
            <!-- 代码生成器 -->
            <plugin>
                <groupId>org.mybatis.generator</groupId>
                <artifactId>mybatis-generator-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
```

插件添加完毕后，在 `/resources` 目录下，创建名为 `generatorConfig.xml` 的配置文件，内容如下:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <context id="mysqlTables" targetRuntime="MyBatis3" defaultModelType="flat">

        <!-- 自动检查关键字，为关键字增加反引号，如：`type` -->
        <property name="autoDelimitKeywords" value="true"/>
        <property name="beginningDelimiter" value="`"/>
        <property name="endingDelimiter" value="`"/>
        <!-- 指定生成的 Java 文件编码 -->
        <property name="javaFileEncoding" value="UTF-8"/>

        <!-- 对生成的注释进行控制 -->
        <commentGenerator>
            <!-- 由于此插件生成的注释不太美观，这里设置不生成任何注释 -->
            <property name="suppressAllComments" value="true"/>
        </commentGenerator>

        <!-- 数据库链接 -->
        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
                        connectionURL="jdbc:mysql://127.0.0.1:3306/xiaohashu"
                        userId="root"
                        password="123456">
            <!-- 解决多个重名的表生成表结构不一致问题 -->
            <property name="nullCatalogMeansCurrent" value="true"/>
        </jdbcConnection>

        <!-- 不强制将所有的数值类型映射为 Java 的 BigDecimal 类型 -->
        <javaTypeResolver>
            <property name="forceBigDecimals" value="false"/>
        </javaTypeResolver>

        <!-- DO 实体类存放路径 -->
        <javaModelGenerator targetPackage="com.quanxiaoha.xiaohashu.auth.domain.dataobject"
                            targetProject="src/main/java"/>

        <!-- Mapper xml 文件存放路径-->
        <sqlMapGenerator targetPackage="mapper"
                         targetProject="src/main/resources"/>

        <!-- Mapper 接口存放路径 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="com.quanxiaoha.xiaohashu.auth.domain.mapper"
                             targetProject="src/main/java"/>

        <!-- 需要生成的表-实体类 -->
        <table tableName="t_user" domainObjectName="UserDO"
               enableCountByExample="false"
               enableUpdateByExample="false"
               enableDeleteByExample="false"
               enableSelectByExample="false"
               selectByExampleQueryId="false"/>
    </context>
</generatorConfiguration>
```

> 解释一下各项配置的含义：
>
> - `generatorConfiguration` 标签是根标签，用于定义整个配置文件的内容。
>
> - ```
>   context
>   ```
>
>    
>
>   标签定义了一个上下文，用于指定生成代码的一些全局配置和规则。
>
>   - `id` 属性指定了上下文的唯一标识符，这里是 `mysqlTables`。
>   - `targetRuntime` 属性指定了生成代码的目标运行时环境，这里是 `MyBatis3`。
>   - `defaultModelType` 属性指定了生成代码时默认的模型类型，这里是 `flat`，表示生成的实体类是扁平化的。
>
> - ```
>   property
>   ```
>
>    
>
>   标签用于配置一些属性。
>
>   - `autoDelimitKeywords` 属性设置为 `true` 表示自动检查关键字，为关键字增加反引号。
>   - `beginningDelimiter` 和 `endingDelimiter` 属性指定了起始和结束的引号。
>   - `javaFileEncoding` 属性指定了生成的 Java 文件的编码为 UTF-8。
>
> - `commentGenerator` 标签用于配置注释生成器，这里设置 `suppressAllComments` 属性为 `true` 表示不生成任何注释。
>
> - `jdbcConnection` 标签用于配置数据库连接信息，包括驱动类、连接 URL、用户名和密码。
>
> - `javaTypeResolver` 标签用于配置 Java 类型解析器，这里设置 `forceBigDecimals` 属性为 `false` 表示不强制将所有的数值类型映射为 Java 的 BigDecimal 类型。
>
> - `javaModelGenerator` 标签用于配置生成的 DO 实体类存放路径。
>
> - `sqlMapGenerator` 标签用于配置生成的 Mapper XML 文件存放路径。
>
> - `javaClientGenerator` 标签用于配置生成的 Mapper 接口存放路径。
>
> - ```
>   table
>   ```
>
>    
>
>   标签用于指定需要生成的表和对应的实体类。
>
>   - `tableName` 属性指定了数据库中的表名。
>   - `domainObjectName` 属性指定了生成的实体类的名称。
>   - `enableCountByExample`、`enableUpdateByExample`、`enableDeleteByExample`、`enableSelectByExample` 属性用于指定是否启用相关方法的生成。
>   - `selectByExampleQueryId` 属性用于指定是否生成查询方法的 ID。

点击右侧栏 `mybatis-generator` 插件的 `generate` 方法，开始生成：
## 异步日志打印
在构建任何应用程序时，良好的日志管理都是必不可少的。日志可以帮助我们监控、调试和跟踪代码的运行情况。 本小节中，我们继续完善 xiaohashu-auth 认证服务的项目骨架，为其整合 Logback 日志框架，并将配置日志的异步写入文件，以提升应用性能。

TIP : 关于 Logback 理论介绍部分，可翻阅星球第一个项目 3.5 小节 ，这里不再赘述，直接上手实操。

1. 添加日志配置文件
   编辑 xiaohashu-auth 认证服务，在 /resources 资源目录下，创建名为 logback-spring.xml 日志配置文件：



文件内容如下：

<configuration>
    <!-- 引用 Spring Boot 的 logback 基础配置 -->
    <include resource="org/springframework/boot/logging/logback/defaults.xml" />

    <!-- 应用名称 -->
    <property scope="context" name="appName" value="auth"/>
    <!-- 自定义日志输出路径，以及日志名称前缀 -->
    <property name="LOG_FILE" value="./logs/${appName}.%d{yyyy-MM-dd}"/>
    <!-- 每行日志输出的格式 -->
    <property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"/>

    <!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!-- 日志文件的命名格式 -->
            <fileNamePattern>${LOG_FILE}-%i.log</fileNamePattern>
            <!-- 保留 30 天的日志文件 -->
            <maxHistory>30</maxHistory>
            <!-- 单个日志文件最大大小 -->
            <maxFileSize>10MB</maxFileSize>
            <!-- 日志文件的总大小，0 表示不限制 -->
            <totalSizeCap>0</totalSizeCap>
            <!-- 重启服务时，是否清除历史日志，不推荐清理 -->
            <cleanHistoryOnStart>false</cleanHistoryOnStart>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 本地 dev 开发环境 -->
    <springProfile name="dev">
        <include resource="org/springframework/boot/logging/logback/console-appender.xml" />
        <root level="INFO">
            <appender-ref ref="CONSOLE"/> <!-- 输出控制台日志 -->
            <appender-ref ref="FILE"/> <!-- 打印日志到文件中。PS: 本地环境下，如果不想打印日志到文件，可注释掉此行 -->
        </root>
    </springProfile>

    <!-- 其它环境 -->
    <springProfile name="prod">
        <include resource="org/springframework/boot/logging/logback/console-appender.xml" />
        <root level="INFO">
            <appender-ref ref="FILE"/> <!-- 生产环境下，仅打印日志到文件中 -->
        </root>
    </springProfile>

</configuration>
说一下日志配置文件中，每项配置都是干啥的：

基础配置和属性定义：
<include resource="org/springframework/boot/logging/logback/defaults.xml" />
上述配置用于引用 Spring Boot 的默认 Logback 基础配置。

<property scope="context" name="appName" value="auth"/>
<property name="LOG_FILE" value="./logs/${appName}.%d{yyyy-MM-dd}"/>
<property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"/>
定义了一些全局属性：

appName：应用名称，这里值填写为 auth ，表示认证服务。

LOG_FILE：日志文件的路径和文件名模板， ./logs 表示输出到项目的同级目录下的 /logs 文件夹下。

LOG_PATTERN：日志输出格式。

日志文件 Appender 配置：

<appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
        <fileNamePattern>${LOG_FILE}-%i.log</fileNamePattern>
        <maxHistory>30</maxHistory>
        <maxFileSize>10MB</maxFileSize>
        <totalSizeCap>0</totalSizeCap>
        <cleanHistoryOnStart>false</cleanHistoryOnStart>
    </rollingPolicy>
    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
        <pattern>${LOG_PATTERN}</pattern>
        <charset>UTF-8</charset>
    </encoder>
</appender>
appender：用于将日志输出到文件，并且使用滚动策略来管理日志文件。

rollingPolicy：定义了日志滚动策略，使用 SizeAndTimeBasedRollingPolicy 以时间和大小为基准进行滚动。

fileNamePattern：定义了日志文件的命名模式。

maxHistory：保留 30 天的日志文件。

maxFileSize：每个日志文件最大 10MB。

totalSizeCap：总日志文件大小没有限制。

cleanHistoryOnStart：项目启动时不清理历史日志文件。

encoder：定义了日志的输出格式，以及文件编码格式。

Spring Profile 配置：用于配置各环境的日志行为。这里主要定义了 dev 和 prod 两个环境：

<springProfile name="dev">
   <include resource="org/springframework/boot/logging/logback/console-appender.xml" />
    <root level="INFO">
       <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/> 
    </root>
</springProfile>
dev 本地开发环境中，包含控制台输出 CONSOLE 和文件输出 FILE。CONSOLE 配置通过包含 Spring Boot 默认的 console-appender.xml 实现。

<springProfile name="prod">
   <include resource="org/springframework/boot/logging/logback/console-appender.xml" />
    <root level="INFO">
       <appender-ref ref="FILE"/> 
    </root>
</springProfile>
prod 生产环境中，仅包含文件输出 FILE，不输出到控制台。这是为了生产环境中减少控制台日志输出，避免影响性能。

拓展小知识 : 如果你想同时设置多个环境，假设咱们除了本地开发环境、生产环境外，还有个 test 测试环境， 也仅需要输出日志到文件。则可以配置如下，通过逗号 , 分隔开来就行：

<springProfile name="test,prod">
    // 省略...
</springProfile>
2. 测试看看效果
因为我们上面通过 springProfile , 配置了 dev 开发环境中，打印日志到文件中。接下来，重启项目，实测一下看看功能是否正常：



项目启动成功后，如上图所示，进入到项目的 /logs 文件夹下，可以看到日志输出是 ok 的。

3. 异步日志
   异步打印日志（Asynchronous Logging）是一种日志记录方式，它将日志写入操作放在一个单独的线程中执行，而不是在主线程中进行。这意味着日志写入的过程不会阻塞主线程的执行，主线程可以继续执行其余的业务逻辑，增强了应用的性能和响应速度。

3.1 为什么需要异步打印日志
性能提升：同步日志记录在高并发情况下会显著影响应用性能，因为每一次日志写入操作都可能导致磁盘 I/O 操作，主线程必须等待这些操作完成才能继续执行。异步日志记录将这些操作放在单独的线程中进行，避免了主线程的阻塞，提高了整体性能。

响应时间：异步日志记录可以减少应用的响应时间，尤其是在需要记录大量日志信息的时候。用户请求得到快速响应，而日志记录在后台处理。

资源利用：通过异步日志记录，应用可以更有效地利用 CPU 资源。同步日志记录可能导致线程频繁等待 I/O 操作完成，而异步记录可以让这些线程去执行其他任务，提高资源利用率。

系统稳定性：在极端情况下（例如，日志量非常大时），同步日志记录可能会导致应用出现性能瓶颈甚至崩溃。异步日志记录通过缓冲和队列机制，能够更好地应对突发的大量日志请求，增强系统稳定性。

3.2 Logback 配置异步日志
Logback 提供了 AsyncAppender 来支持异步日志记录。通过 AsyncAppender 可以将日志事件发送到一个队列中，并由一个独立的线程池来处理这些日志事件。编辑 logback-spring.xml 文件，添加配置如下：

	// 省略...

	<!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
		// 省略...
    </appender>

    <!-- 异步写入日志，提升性能 -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 是否丢弃日志, 0 表示不丢弃。默认情况下，如果队列满 80%, 会丢弃 TRACE、DEBUG、INFO 级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 队列大小。默认值为 256 -->
        <queueSize>256</queueSize>
        <appender-ref ref="FILE"/>
    </appender>
    
    <!-- 本地 dev 开发环境 -->
    <springProfile name="dev">
        <include resource="org/springframework/boot/logging/logback/console-appender.xml" />
        <root level="INFO">
            <appender-ref ref="CONSOLE"/> <!-- 输出控制台日志 -->
            <appender-ref ref="ASYNC_FILE"/> <!-- 打印日志到文件中。PS: 本地环境下，如果不想打印日志到文件，可注释掉此行 -->
        </root>
    </springProfile>

    <!-- 其它环境 -->
    <springProfile name="prod">
        <include resource="org/springframework/boot/logging/logback/console-appender.xml" />
        <root level="INFO">
            <appender-ref ref="ASYNC_FILE"/> <!-- 生产环境下，仅打印日志到文件中 -->
        </root>
    </springProfile>
    
    // 省略...
解释一下修改的地方，主要添加了一个名称为 ASYNC_FILE 异步输出日志的 Appender：

AsyncAppender 使用内部队列来异步处理日志事件。
queueSize：队列的大小。
discardingThreshold：是否丢弃日志, 0 表示不丢弃。
最后，将各个环境中的 FILE 更改为 ASYNC_FILE 异步写入日志。别忘了，再次重启一下项目，自测一波日志功能是否好使~


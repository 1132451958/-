# 小哈书

## 1. 什么是 Spring Boot Starter ?

Spring Boot Starter 就像是一个“工具包”，里面已经包含了你所需要的东西。它们把一些常用的功能和技术打包好了，比如处理数据库、处理 Web 请求等等。你只需要在你的项目中引入这些 Starter，它们就会自动帮你配置好所需的依赖项和参数。这样，你就可以省去很多繁琐的配置工作。

举个栗子，当你想要使用 Spring Boot 开发一个 Web 应用时，只需要引入 `spring-boot-starter-web` Starter。这个 Starter 包含了一系列依赖项和配置，使得开发 Web 应用变得更加简单。

具体来说，引入 `spring-boot-starter-web` Starter 后，你可以享受到以下好处：

- **内嵌的 Web 服务器支持**：Spring Boot 内置了多种 Web 服务器支持，比如 Tomcat、Jetty、Undertow。`spring-boot-starter-web` 会自动配置一个默认的 Web 服务器，你无需手动配置即可启动你的应用。
- **Spring MVC 框架支持**：Spring Boot 基于 Spring MVC 构建了强大的 Web 开发框架，包括了控制器、视图解析器等。引入 `spring-boot-starter-web` 后，你可以直接使用 Spring MVC 来处理 Web 请求。
- **静态资源支持**：`spring-boot-starter-web` Starter 自动配置了对静态资源（如 HTML、CSS、JavaScript 文件）的处理，你可以直接在项目中放置这些文件，Spring Boot 就能够正确地访问它们。
- **自动配置**：Spring Boot 会根据你的 classpath 自动配置应用程序。比如，如果你引入了 `spring-boot-starter-web`，Spring Boot 就会自动配置 DispatcherServlet、ViewResolver 等关键组件，从而让你的 Web 应用能够顺利地工作起来。

简而言之，Spring Boot Starter 是一种方便的方式，让你能够更快、更轻松地开始使用 Spring Boot 框架，并集成各种常用功能和技术。

## 2.JSON 工具类

由于在**日志切面** `starter` 组件中，需要以 `json` 的格式打印出参，所以，我们需要先封装一个 `Json` 工具类。

##  3.配置类

- **`@Configuration`** 是 Spring 中用于定义普通配置类的注解，开发者手动定义 Bean 和其他配置。
- **`@AutoConfiguration`** 是 Spring Boot 中用于标记自动配置类的注解，它通常与条件注解一起使用，根据类路径和环境自动决定是否启用某个配置。
- **`@EnableAutoConfiguration`** 启用自动配置机制，通常通过 `@SpringBootApplication` 注解来间接使用。

## 4.自定义starter

### **自定义 Starter 的结构**

一个标准的自定义 Starter 主要包含以下几部分：

1. **`META-INF/spring.factories` 文件**：用于注册自动配置类，Spring Boot 会根据这个文件自动加载和启用相应的配置。
2. **自动配置类**：封装具体的功能和配置，比如数据库连接池、消息队列等的自动配置。
3. **依赖**：你可能会在 Starter 中添加一些常用的库和框架，简化其他开发者的配置工作。
4. **其他资源**：如配置文件模板、静态资源等。

#### 第一步：创建 Starter 项目

创建一个新的 Maven 或 Gradle 项目，这个项目将作为你的自定义 Starter。

例如，使用 Maven，你可以创建一个新的模块，命名为 `my-logging-starter`。

#### 第二步：创建自动配置类

自动配置类负责实现 Spring Boot 的自动配置功能，通常使用 `@Configuration` 注解。你可以在自动配置类中使用 `@Conditional` 系列注解来根据环境条件自动配置特定的 Bean。

```java
package com.example.logging.config;

import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties(LoggingProperties.class)  // 加载自定义的属性
public class LoggingAutoConfiguration {

    @Bean
    public LoggingService loggingService() {
        return new LoggingServiceImpl();
    }

    // 其他的自动配置...
}
```

#### 第三步：创建 `META-INF/spring.factories` 文件

在 `src/main/resources/META-INF/` 目录下创建 `spring.factories` 文件，并在其中注册你的自动配置类。

**文件路径**：

```bash
bash /src/main/resources/META-INF/spring.factories
```

**内容示例**：

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.logging.config.LoggingAutoConfiguration
```

该文件告诉 Spring Boot 在启动时自动加载 `LoggingAutoConfiguration` 配置类。

#### 第四步：定义配置属性类（如果需要）

如果你希望允许用户在 `application.properties` 或 `application.yml` 文件中配置自定义的属性，可以创建一个配置属性类。

```java
package com.example.logging.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "logging")
public class LoggingProperties {

    private String logLevel;
    private String logFilePath;

    // Getters and Setters
}
```

#### 第五步：打包并发布 Starter

完成自动配置类、`spring.factories` 文件、依赖等设置后，你可以将这个 Starter 打包并发布到 Maven 仓库，供其他应用使用。

在 `pom.xml` 中配置你的 Starter 依赖：

```xml
<dependency>
    <groupId>com.example</groupId>
    <artifactId>my-logging-starter</artifactId>
    <version>1.0.0</version>
</dependency>
```

#### 第六步：使用自定义 Starter

在其他 Spring Boot 项目中使用时，只需要在 `pom.xml` 文件中添加对该 Starter 的依赖。Spring Boot 会自动加载和配置该 Starter 中的功能。

### 5. **示例：自定义日志 Starter**

假设我们要创建一个自定义日志 Starter。步骤如下：

#### 1. 创建 Starter 项目

创建一个名为 `my-logging-starter` 的 Maven 模块。

#### 2. 创建自动配置类

```
LoggingAutoConfiguration.java
java复制package com.example.logging.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class LoggingAutoConfiguration {

    @Bean
    public LoggingService loggingService() {
        return new LoggingServiceImpl();
    }
}
```

#### 3. 创建 `spring.factories` 文件

```
src/main/resources/META-INF/spring.factories
properties复制org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.logging.config.LoggingAutoConfiguration
```

#### 4. 创建配置属性类（如果需要）

```
LoggingProperties.java
java复制package com.example.logging.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "logging")
public class LoggingProperties {

    private String logLevel = "INFO";  // 默认值

    // Getter 和 Setter
}
```

#### 5. 创建一个接口和实现类

```
LoggingService.java
java复制package com.example.logging;

public interface LoggingService {
    void log(String message);
}
LoggingServiceImpl.java
java复制package com.example.logging;

public class LoggingServiceImpl implements LoggingService {

    @Override
    public void log(String message) {
        System.out.println("LOG: " + message);
    }
}
```

#### 6. 打包和发布

将整个项目打包成 JAR 文件并上传到 Maven 仓库，或者直接将其作为本地依赖。

#### 7. 在其他项目中使用

在其他 Spring Boot 应用中，添加对 `my-logging-starter` 的依赖：

```xml
<dependency>
    <groupId>com.example</groupId>
    <artifactId>my-logging-starter</artifactId>
    <version>1.0.0</version>
</dependency>
```

Spring Boot 会自动配置日志相关的 Bean。

## 6. 如何进行AOP编程

### 1. **定义 `@Log` 注解**

首先，我们需要定义一个 `@Log` 注解，用来标记需要进行日志记录的业务方法。

```java
package com.example.logging.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// 标注在方法上
@Target(ElementType.METHOD)
// 保留策略为运行时
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
    // 可根据需要添加一些属性，例如日志级别等
    String value() default "";
}
```

### 2. **创建 AOP 切面**

接着，我们需要创建一个 AOP 切面类来拦截所有标注了 `@Log` 注解的方法，打印方法的入参、出参以及运行时间。

#### 依赖

首先，确保你的项目已经引入了 AOP 相关的依赖。如果使用的是 Spring Boot，通常需要引入 `spring-boot-starter-aop` 依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

#### AOP 切面实现

```java
package com.example.logging.aop;

import com.example.logging.annotation.Log;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import java.util.Arrays;

@Aspect
@Component
public class LogAspect {

    private static final Logger logger = LoggerFactory.getLogger(LogAspect.class);

    // 定义切点：拦截所有注解了@Log的方法
    @Pointcut("@annotation(com.example.logging.annotation.Log)")
    public void logMethods() {}

    // 前置通知：方法执行前
    @Before("logMethods()")
    public void logBefore(JoinPoint joinPoint) {
        // 打印方法名称
        String methodName = joinPoint.getSignature().getName();
        // 打印方法入参
        Object[] args = joinPoint.getArgs();
        logger.info("Method [{}] called with arguments: {}", methodName, Arrays.toString(args));
    }

    // 环绕通知：方法执行前后
    @Around("logMethods()")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        // 获取方法名
        String methodName = joinPoint.getSignature().getName();
        // 获取方法入参
        Object[] args = joinPoint.getArgs();
        // 记录方法开始时间
        long startTime = System.currentTimeMillis();

        // 执行目标方法
        Object result = joinPoint.proceed();

        // 记录方法结束时间
        long endTime = System.currentTimeMillis();
        // 打印方法出参和运行时间
        logger.info("Method [{}] executed in {} ms. Arguments: {}. Return: {}", methodName, endTime - startTime, Arrays.toString(args), result);

        return result;
    }

    // 后置通知：方法执行后
    @After("logMethods()")
    public void logAfter(JoinPoint joinPoint) {
        // 这里可以添加日志记录执行完后的操作（如果需要）
    }
}
```

## 7.整合mybatis

将 **Spring Boot** 项目与 **MyBatis** 整合的步骤可以分为几个主要部分：引入依赖、配置数据源、配置 MyBatis、编写实体类、Mapper 接口和 XML 映射文件、以及进行数据库操作。以下是详细的步骤：

### 1. **引入依赖**

首先，在 `pom.xml` 文件中添加 Spring Boot 和 MyBatis 所需的依赖。

```xml
xml复制<dependencies>
    <!-- Spring Boot Starter Web (如果你有 Web 相关需求) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring Boot Starter DataSource (数据库连接池) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    
    <!-- MyBatis Spring Boot Starter -->
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.2.0</version> <!-- 使用最新的版本 -->
    </dependency>
    
    <!-- MySQL 数据库驱动 -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>

    <!-- Spring Boot Starter Test (用于测试) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 2. **配置数据源（`application.properties` 或 `application.yml`）**

在 `application.properties` 或 `application.yml` 中配置数据库连接信息。

#### 使用 `application.properties`：

```properties
properties复制# 数据源配置
spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=your_password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# MyBatis 配置
mybatis.mapper-locations=classpath:/mappers/*.xml
mybatis.type-aliases-package=com.quanxiaoha.xiaohashu.auth.domain.dataobject
mybatis.configuration.map-underscore-to-camel-case=true  # 开启驼峰命名规则
```

#### 使用 `application.yml`：

```yaml
yaml复制spring:
  datasource:
    url: jdbc:mysql://localhost:3306/your_database_name?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC
    username: root
    password: your_password
    driver-class-name: com.mysql.cj.jdbc.Driver

mybatis:
  mapper-locations: classpath:/mappers/*.xml
  type-aliases-package: com.quanxiaoha.xiaohashu.auth.domain.dataobject
  configuration:
    map-underscore-to-camel-case: true  # 开启驼峰命名规则
```

### 3. **创建实体类（POJO）**

创建一个 Java 类，作为数据库表的实体对象。

```java
java复制package com.quanxiaoha.xiaohashu.auth.domain.dataobject;

import java.time.LocalDateTime;

public class UserDO {

    private Long id;
    private String username;
    private String password;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;

    // Getters and Setters

}
```

### 4. **创建 Mapper 接口**

创建一个 MyBatis 的 `Mapper` 接口，定义需要执行的 SQL 操作。

```java
java复制package com.quanxiaoha.xiaohashu.auth.domain.mapper;

import com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface UserDOMapper {

    UserDO selectByPrimaryKey(Long id);

    List<UserDO> selectAll();

    void insert(UserDO user);

    void update(UserDO user);

    void delete(Long id);
}
```

### 5. **创建 Mapper XML 文件**

在 `resources/mappers` 目录下创建 MyBatis 的映射文件（XML）。这个文件用于定义 SQL 语句和结果映射。

#### 例如，创建 `UserDOMapper.xml`：

```xml
xml复制<mapper namespace="com.quanxiaoha.xiaohashu.auth.domain.mapper.UserDOMapper">

    <!-- 查询所有用户 -->
    <select id="selectAll" resultType="com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO">
        SELECT id, username, password, create_time, update_time FROM t_user
    </select>

    <!-- 根据主键查询 -->
    <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultType="com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO">
        SELECT id, username, password, create_time, update_time FROM t_user WHERE id = #{id}
    </select>

    <!-- 插入用户 -->
    <insert id="insert" parameterType="com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO">
        INSERT INTO t_user (username, password, create_time, update_time)
        VALUES (#{username}, #{password}, #{createTime}, #{updateTime})
    </insert>

    <!-- 更新用户 -->
    <update id="update" parameterType="com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO">
        UPDATE t_user
        SET username = #{username}, password = #{password}, update_time = #{updateTime}
        WHERE id = #{id}
    </update>

    <!-- 删除用户 -->
    <delete id="delete" parameterType="java.lang.Long">
        DELETE FROM t_user WHERE id = #{id}
    </delete>

</mapper>
```

### 6. **启用 MyBatis**

Spring Boot 自动配置会扫描 `@Mapper` 注解标记的接口。如果需要自定义 MyBatis 的配置（如更改扫描路径等），可以使用 `@MapperScan` 注解指定扫描路径。

#### 启用 MyBatis 的注解配置（在启动类中）：

```java
java复制package com.quanxiaoha.xiaohashu.auth;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan("com.quanxiaoha.xiaohashu.auth.domain.mapper")  // 扫描 Mapper 接口所在包
public class XiaohashuAuthApplication {

    public static void main(String[] args) {
        SpringApplication.run(XiaohashuAuthApplication.class, args);
    }
}
```

### 7. **创建 Service 层（可选）**

在 Service 层中，你可以调用 Mapper 接口来执行数据库操作。

```java
java复制package com.quanxiaoha.xiaohashu.auth.service;

import com.quanxiaoha.xiaohashu.auth.domain.dataobject.UserDO;
import com.quanxiaoha.xiaohashu.auth.domain.mapper.UserDOMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserService {

    @Autowired
    private UserDOMapper userDOMapper;

    public UserDO getUserById(Long id) {
        return userDOMapper.selectByPrimaryKey(id);
    }

    public List<UserDO> getAllUsers() {
        return userDOMapper.selectAll();
    }

    public void createUser(UserDO user) {
        userDOMapper.insert(user);
    }

    public void updateUser(UserDO user) {
        userDOMapper.update(user);
    }

    public void deleteUser(Long id) {
        userDOMapper.delete(id);
    }
}
```

## 8.数据库密码加密

代码如下：

```typescript
package com.quanxiaoha.xiaohashu.auth;

import com.alibaba.druid.filter.config.ConfigTools;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;


@SpringBootTest
@Slf4j
class DruidTests {


    /**
     * Druid 密码加密
     */
    @Test
    @SneakyThrows
    void testEncodePassword() {
        // 你的密码
        String password = "123456";
        String[] arr = ConfigTools.genKeyPair(512);

        // 私钥
        log.info("privateKey: {}", arr[0]);
        // 公钥
        log.info("publicKey: {}", arr[1]);

        // 通过私钥加密密码
        String encodePassword = ConfigTools.encrypt(arr[0], password);
        log.info("password: {}", encodePassword);
    }

}
```

> 解释一下上述代码：
>
> 1. `String password = "123456";`：定义了要加密的密码。
> 2. `String[] arr = ConfigTools.genKeyPair(512);`：调用 `ConfigTools` 类的 `genKeyPair` 方法生成 RSA 密钥对。RSA 是一种非对称加密算法，`512` 表示密钥长度为 512 位。
> 3. `log.info("privateKey: {}", arr[0]);` 和 `log.info("publicKey: {}", arr[1]);`：分别打印生成的私钥和公钥。私钥用于加密，公钥用于解密。
> 4. `String encodePassword = ConfigTools.encrypt(arr[0], password);`：调用 `ConfigTools` 类的 `encrypt` 方法，使用生成的私钥对密码进行加密。这里将生成的私钥和密码作为参数传入，返回加密后的密码。
> 5. `log.info("password: {}", encodePassword);`：打印加密后的密码。

核心配置如下：

```yaml
spring:
  datasource:
    // 省略...
    password: A2qT03X7KlL4v/F2foD6kV/Ch9gpNBWOh1qoCywanjv1AsI7f9x3iAyR9NkUKeV+FMo+halCTzy5Llbk2VOrVQ== # 数据库密码
    type: com.alibaba.druid.pool.DruidDataSource
    druid: # Druid 连接池
      // 省略...
      connectionProperties: config.decrypt=true;config.decrypt.key=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIaJmhsfN14oM+bghiOfARP6YgIiArekviyAOEa9Dt8spf4W38kSJShGs0NkzT3btqJB0O2o0X/yfVE8kqme1jMCAwEAAQ==
      // 省略...
      filter:
        config:
          enabled: true
        // 省略...
```

> 解释一下上述配置项：
>
> 1. `password: A2qT03X7KlL4v/F2foD6kV/Ch9gpNBWOh1qoCywanjv1AsI7f9x3iAyR9NkUKeV+FMo+halCTzy5Llbk2VOrVQ==`：这里的密码改为加密后的密码。
> 2. `connectionProperties: config.decrypt=true;config.decrypt.key=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIaJmhsfN14oM+bghiOfARP6YgIiArekviyAOEa9Dt8spf4W38kSJShGs0NkzT3btqJB0O2o0X/yfVE8kqme1jMCAwEAAQ==`：这里配置了连接属性，其中 `config.decrypt=true` 表示开启密码解密功能，`config.decrypt.key` 是用于解密的密钥，即上面单元测试生成**公钥**。在 Druid 连接池中，如果我们的密码已经经过了加密处理，就需要在连接属性中配置解密相关的参数，以便 Druid 能够正确解密密码，然后连接到数据库。
> 3. `filter.config.enabled: true`：这里配置了 Druid 连接池的 `filter`，其中 `config` 是一个配置项，`enabled: true` 表示开启该配置项。这个配置项通常用于配置 Druid 连接池的一些额外功能，比如密码解密等。

## 9.根据数据库表自动生成do，mapper与mapper.xml

在 `pom.xml` 文件中添加该插件：

```php-template
    <build>
        <plugins>
			// 省略...
			
            <!-- 代码生成器 -->
            <plugin>
                <groupId>org.mybatis.generator</groupId>
                <artifactId>mybatis-generator-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
```

插件添加完毕后，在 `/resources` 目录下，创建名为 `generatorConfig.xml` 的配置文件，内容如下:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <context id="mysqlTables" targetRuntime="MyBatis3" defaultModelType="flat">

        <!-- 自动检查关键字，为关键字增加反引号，如：`type` -->
        <property name="autoDelimitKeywords" value="true"/>
        <property name="beginningDelimiter" value="`"/>
        <property name="endingDelimiter" value="`"/>
        <!-- 指定生成的 Java 文件编码 -->
        <property name="javaFileEncoding" value="UTF-8"/>

        <!-- 对生成的注释进行控制 -->
        <commentGenerator>
            <!-- 由于此插件生成的注释不太美观，这里设置不生成任何注释 -->
            <property name="suppressAllComments" value="true"/>
        </commentGenerator>

        <!-- 数据库链接 -->
        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
                        connectionURL="jdbc:mysql://127.0.0.1:3306/xiaohashu"
                        userId="root"
                        password="123456">
            <!-- 解决多个重名的表生成表结构不一致问题 -->
            <property name="nullCatalogMeansCurrent" value="true"/>
        </jdbcConnection>

        <!-- 不强制将所有的数值类型映射为 Java 的 BigDecimal 类型 -->
        <javaTypeResolver>
            <property name="forceBigDecimals" value="false"/>
        </javaTypeResolver>

        <!-- DO 实体类存放路径 -->
        <javaModelGenerator targetPackage="com.quanxiaoha.xiaohashu.auth.domain.dataobject"
                            targetProject="src/main/java"/>

        <!-- Mapper xml 文件存放路径-->
        <sqlMapGenerator targetPackage="mapper"
                         targetProject="src/main/resources"/>

        <!-- Mapper 接口存放路径 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="com.quanxiaoha.xiaohashu.auth.domain.mapper"
                             targetProject="src/main/java"/>

        <!-- 需要生成的表-实体类 -->
        <table tableName="t_user" domainObjectName="UserDO"
               enableCountByExample="false"
               enableUpdateByExample="false"
               enableDeleteByExample="false"
               enableSelectByExample="false"
               selectByExampleQueryId="false"/>
    </context>
</generatorConfiguration>
```

> 解释一下各项配置的含义：
>
> - `generatorConfiguration` 标签是根标签，用于定义整个配置文件的内容。
>
> - ```
>   context
>   ```
>
>    
>
>   标签定义了一个上下文，用于指定生成代码的一些全局配置和规则。
>
>   - `id` 属性指定了上下文的唯一标识符，这里是 `mysqlTables`。
>   - `targetRuntime` 属性指定了生成代码的目标运行时环境，这里是 `MyBatis3`。
>   - `defaultModelType` 属性指定了生成代码时默认的模型类型，这里是 `flat`，表示生成的实体类是扁平化的。
>
> - ```
>   property
>   ```
>
>    
>
>   标签用于配置一些属性。
>
>   - `autoDelimitKeywords` 属性设置为 `true` 表示自动检查关键字，为关键字增加反引号。
>   - `beginningDelimiter` 和 `endingDelimiter` 属性指定了起始和结束的引号。
>   - `javaFileEncoding` 属性指定了生成的 Java 文件的编码为 UTF-8。
>
> - `commentGenerator` 标签用于配置注释生成器，这里设置 `suppressAllComments` 属性为 `true` 表示不生成任何注释。
>
> - `jdbcConnection` 标签用于配置数据库连接信息，包括驱动类、连接 URL、用户名和密码。
>
> - `javaTypeResolver` 标签用于配置 Java 类型解析器，这里设置 `forceBigDecimals` 属性为 `false` 表示不强制将所有的数值类型映射为 Java 的 BigDecimal 类型。
>
> - `javaModelGenerator` 标签用于配置生成的 DO 实体类存放路径。
>
> - `sqlMapGenerator` 标签用于配置生成的 Mapper XML 文件存放路径。
>
> - `javaClientGenerator` 标签用于配置生成的 Mapper 接口存放路径。
>
> - ```
>   table
>   ```
>
>    
>
>   标签用于指定需要生成的表和对应的实体类。
>
>   - `tableName` 属性指定了数据库中的表名。
>   - `domainObjectName` 属性指定了生成的实体类的名称。
>   - `enableCountByExample`、`enableUpdateByExample`、`enableDeleteByExample`、`enableSelectByExample` 属性用于指定是否启用相关方法的生成。
>   - `selectByExampleQueryId` 属性用于指定是否生成查询方法的 ID。

点击右侧栏 `mybatis-generator` 插件的 `generate` 方法，开始生成：
